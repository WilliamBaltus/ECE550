`timescale 1 ns / 100 ps

module skeleton_tb;

    // Testbench signals
    reg clock;
    reg reset;

    // Clocks generated by the skeleton module
    wire imem_clock;
    wire dmem_clock;
    wire processor_clock;
    wire regfile_clock;

    // Declare integer for loop
    integer i;

    // Instantiate the skeleton module
    skeleton uut (
        .clock(clock),
        .reset(reset),
        .imem_clock(imem_clock),
        .dmem_clock(dmem_clock),
        .processor_clock(processor_clock),
        .regfile_clock(regfile_clock)
    );

    // Generate main clock (50 MHz, 20 ns period)
    always #10 clock = ~clock;

    initial begin
        // Display initial message to confirm testbench starts
        $display("Starting testbench...");

        // Initialize clock and reset
        clock = 0;
        reset = 1;
        
        // Wait a few cycles, then deassert reset
        #20 reset = 0;
        $display("Reset deasserted");

        // Let the processor clock run for a couple of cycles
        repeat (4) @(posedge processor_clock);

        // Display register values after a few cycles
        $display("Observing register file data after initial processor cycles...");
        $display("Register values:");
        
        // Loop through and display register values
        for (i = 0; i < 32; i = i + 1) begin
            $display("Register %0d: %h", i, uut.my_regfile.registers[i]);
        end

        // Run a few more processor cycles and display selected registers
        repeat (4) @(posedge processor_clock);
        $display("Time: %0t | Additional register check after more cycles", $time);
        $display("Reg 0: %h | Reg 1: %h | Reg 2: %h",
                 uut.my_regfile.registers[0], uut.my_regfile.registers[1], uut.my_regfile.registers[2]);

        // End simulation
        $display("Ending testbench.");
        $finish;
    end

endmodule
